<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Events</title>
</head>
<body style="background-color: #414141; color: aliceblue;">
    <h2>Amazing image</h2>
    <div >
        <ul id="images">
            <li><img width="200px" id="photoshop" src="https://images.pexels.com/photos/3561339/pexels-photo-3561339.jpeg?auto=compress&cs=tinysrgb&w=1600&lazy=load" alt="photoshop"></li>
            <li><img width="200px" id="japan" src="https://images.pexels.com/photos/3532553/pexels-photo-3532553.jpeg?auto=compress&cs=tinysrgb&w=1600&lazy=load" alt=""></li>
            <li><img width="200px" id="river" src="https://images.pexels.com/photos/3532551/pexels-photo-3532551.jpeg?auto=compress&cs=tinysrgb&w=1600&lazy=load" alt=""></li>
            <!-- <li><img width="200px" id="owl" src="https://images.pexels.com/photos/3532552/pexels-photo-3532552.jpeg?auto=compress&cs=tinysrgb&w=1600&lazy=load" alt=""  onclick="alert('owl')"></li> -->
            <!-- While this might work in this case , it has scaling issues  -->
            <li><img width="200px" id="owl" src="https://images.pexels.com/photos/3532552/pexels-photo-3532552.jpeg?auto=compress&cs=tinysrgb&w=1600&lazy=load" alt="" ></li>
            <li><img width="200px" id="prayer" src="https://images.pexels.com/photos/2522671/pexels-photo-2522671.jpeg?auto=compress&cs=tinysrgb&w=1600&lazy=load" alt=""></li>
            <li><a style="color: aliceblue;" href="https://google.com" id="google">Google</a></li>
        </ul>
   </div>
</body>

<script>
// Since JavaScript is single-threaded, processes in JavaScript are executed sequentially, one after the other, within a single call stack. However, many operations such as browser events (e.g., clicks, key presses), API calls, timers (e.g., setTimeout, setInterval), and file reading are inherently asynchronous and would block the main thread if executed synchronously. To handle these tasks without blocking the main thread and freezing the UI, JavaScript uses an event-driven, non-blocking model powered by the Event Loop, Web APIs, and the callback queue. 

/* Here comes the Event Loop, the traffic cop of JavaScript.

It watches two areas:

The Call Stack (Is JS busy?)

The Callback Queue (Are any async tasks done and ready?)

When the Call Stack is empty, the Event Loop moves a finished task from the Callback Queue into the Call Stack.

So asynchronous code doesn’t interrupt — it waits politely until JavaScript is free.
 */


// document.getElementById('owl').onclick= function()
// {
//     alert("owl with Js")
// }

// document.getElementById('owl').onclick= () =>
// {
//     alert("owl with Js")
// }

// document.getElementById('owl').onclick= () =>  alert("owl with Js") ;


/* This is good , but it provides less functionalities . Instead we use Event Listeners . */


// document.getElementById('prayer').addEventListener('click',function(){

//     alert("prayed using event listener") 
// },false)

// document.getElementById('owl').addEventListener('click',function(e)
// {
//     console.log(e)
// },false)

/* IMP events to read 
// type , timestamp , defaultPrevented

// target ,toElement ,srcElement ,currentTarget

//clientX , clientY , screenX , screenY , tiltX , tiltY 

// altkey , ctrlkey ,shiftkey , keyCode */


/* Event Bubbling vs Event Capturing 

false in addEventListener means that the event is in the bubbling phase . */




// document.getElementById('images').addEventListener('click',function(e)
// {
//     console.log("Mangesh Kalicharan") ;
// },false)


// document.getElementById('japan').addEventListener('click',function(e)
// {
//     console.log("Hikaru Nakamura");
//     // to stop propagation to outer element

//     e.stopPropagation();
// },false)

document.getElementById("google").addEventListener('click',(e)=>
{   
    e.preventDefault() ;
    e.stopPropagation() ;
    let removeIt=e.target.parentNode
    removeIt.remove()
    console.log("Google clicked");

},false)

// Since japan is inside images, on clicking on japan , both messages will be displayed

// document.querySelector('#images').addEventListener('click',(e)=>
// {     
//     console.log(e.target.parentNode);

//     let removeIt=e.target.parentNode
//     removeIt.remove()

// },false)


//isse pura broser bhi udd sakta hain 


document.querySelector('#images').addEventListener('click',(e)=>
{
      if(e.target.tagName=='IMG')
      {
        console.log(e.target.parentNode);

       let removeIt=e.target.parentNode
       removeIt.remove()
      }
},false)




</script>
</html>